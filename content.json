{"pages":[{"title":"About me","text":"我曾七次鄙视自己的灵魂：第一次，当它本可进取时，却故作谦卑；第二次，当它在空虚时，用爱欲来填充；第三次，在困难和容易之间，它选择了容易；第四次，它犯了错,却借由别人也会犯错来宽慰自己；第五次，它自由软弱，却把它认为是生命的坚韧；第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；第七次，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; –By 纪伯伦 仅以此句，献给余生。","link":"/about/index.html"}],"posts":[{"title":"CSS-Study","text":"&gt;&gt;CSS如何工作 Load HTML Parse HTML Load CSS Parse CSS (Attach style to DOM nodes) Create DOM Tree Display 关于DOM DOM是一种树形结构. 标记语言中的每个元素,属性,文本片段都变为一个 DOM 节点。这些节点由它们与其它 DOM 节点的关系来定义。有的元素是某些子节点的父节点，且这些子节点有兄弟（节点）。由于 DOM 是 CSS 与文档内容的相遇之处，理解 DOM 有助于设计，调试和维护你的 CSS 文件。 认识CSS从最基本的角度来看,CSS是由两块内容组成的: 属性（Property）: 指出所修改的样式 属性值(Value)： 表示要把样式特征修改成什么样 语法细节CSS声明给 CSS 属性设置特定的值是 CSS 语言的核心功能。CSS 引擎会通过计算，将对应的 CSS 声明应用到页面的每一个元素上，从而使得元素们以适当的方式布局，并展示出适当的样式。特别需要记住的是，CSS 的属性和属性值都是区分大小写的。属性和属性值之间，用英文半角冒号 (:) 隔离 CSS声明块声明按块分组，每一组声明都用一对大括号包裹，用 ({) 开始，用 (}) 结束。声明块里的每一个声明必须用半角分号（;）分隔，否则代码会不生效（至少不会按预期结果生效）。声明块里的最后一个声明结束的地方，不需要加分号，但是最后加分号是个好习惯，因为可以防止在后续增加声明时忘记加分号。 CSS选择器和规则通过在每个声明块前加上选择器（selector）来完成这一动作，选择器是一种模式，它能在页面上匹配一些元素。这将使相关的声明仅被应用到被选择的元素上。选择器加上声明块被称为规则集（ruleset），通常简称规则（rule）。 CSS的选择器（重点）选择器可以被分为以下类别： 简单选择（Simple selectors）： 通过元素类型,Class或id匹配一个或多个元素。 属性选择器（Attribute selectors）：通过 属性 / 属性值 匹配一个或多个元素。 伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素，或当前被选中或未选中的复选框，或元素是DOM树中一父节点的第一个子节点。 伪元素（Pseudo-elements）:匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字，或者某个元素之前生成的内容。 组合器（Combinators）：这里不仅仅是选择器本身，还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。例如，你可以只选择divs的直系子节点的段落，或者直接跟在headings后面的段落。 多重选择器（Multiple selectors）：这些也不是单独的选择器；这个思路是将以逗号分隔开的多个选择器放在一个CSS规则下面， 以将一组声明应用于由这些选择器选择的所有元素。","link":"/2019/07/15/CSS-Study/"},{"title":"Git 命令","text":"&gt;&gt; 创建仓库：git initGit 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。 使用方法使用当前目录作为Git仓库，我们只需使它初始化。 1git init 该命令执行完后会在当前目录生成一个 .git 目录。 使用我们指定目录作为Git仓库。 1git init newrepo 初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： 123$ git add *.c$ git add README$ git commit -m '初始化项目版本' 以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。 git clone我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。 克隆仓库的命令格式为： 1git clone &lt;repo&gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式： 1git clone &lt;repo&gt; &lt;directory&gt; 参数说明： repo:Git 仓库。 directory:本地目录。 比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： 1$ git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。 如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字： 1$ git clone git://github.com/schacon/grit.git mygrit 基本操作：git addgit add 命令可将该文件添加到缓存，如我们添加以下两个文件： 12345678$ touch README$ touch hello.php$ lsREADME hello.php$ git status -s?? README?? hello.php$ git status 命令用于查看项目的当前状态。 接下来我们执行 git add 命令来添加文件： 1$ git add README hello.php 现在我们再执行 git status，就可以看到这两个文件已经加上去了。 1234$ git status -sA READMEA hello.php$ git status 命令用于查看项目的当前状态。 接下来我们执行 git add 命令来添加文件： 1$ git add README hello.php 现在我们再执行 git status，就可以看到这两个文件已经加上去了。 1234$ git status -sA READMEA hello.php$ git statusgit status 以查看在你上次提交之后是否有修改。 我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容： 12345678910$ git statusOn branch masterInitial commitChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: README new file: hello.php git diff执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。 git commit使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。 Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。 12$ git config --global user.name 'runoob'$ git config --global user.email test@runoob.com 接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。 12345678910$ git add hello.php$ git status -sA READMEA hello.php$ git commit -m '第一次版本提交'[master (root-commit) d32cf1f] 第一次版本提交 2 files changed, 4 insertions(+) create mode 100644 README create mode 100644 hello.php 现在我们已经记录了快照。如果我们再执行 git status: 123$ git status# On branch masternothing to commit (working directory clean) 以上输出说明我们在最近一次提交之后，没有做任何改动，是一个”working directory clean：干净的工作目录”。 分支管理:几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。 列出分支创建分支命令： 1git branch (branchname) 切换分支命令: 1git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: 1git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。 开始前我们先创建一个测试目录： 12345678910$ mkdir gitdemo$ cd gitdemo/$ git initInitialized empty Git repository...$ touch README$ git add README$ git commit -m '第一次版本提交'[master (root-commit) 3b58100] 第一次版本提交 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README 列出分支基本命令： 1git branch 没有参数时，git branch 会列出你在本地的分支。 12$ git branch* master 此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。 当你执行 git init 的时候，缺省情况下 Git 就会为你创建 master 分支。 如果我们要手动创建一个分支。执行 git branch (branchname) 即可。 1234$ git branch testing$ git branch* master testing 现在我们可以看到，有了一个新分支 testing。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。 接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 1234567891011121314$ lsREADME$ echo 'runoob.com' &gt; test.txt$ git add .$ git commit -m 'add test.txt'[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME test.txt$ git checkout testingSwitched to branch 'testing'$ lsREADME 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。 删除分支删除分支命令： 1git branch -d (branchname) 例如我们要删除 testing 分支： 1234567$ git branch* master testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master 分支合并一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： 12345678910111213141516git merge$ git branch* master newtest$ lsREADME test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。 合并完后就可以删除分支: 12$ git branch -d newtestDeleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了： 12$ git branch* master 查看提交历史在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。 针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下： 1234567891011121314151617181920212223$ git logcommit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)Merge: c68142b 7774248Author: runoob &lt;test@runoob.com&gt;Date: Fri May 3 15:55:58 2019 +0800 Merge branch 'change_site'commit c68142b562c260c3071754623b08e2657b4c6d5bAuthor: runoob &lt;test@runoob.com&gt;Date: Fri May 3 15:52:12 2019 +0800 修改代码commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)Author: runoob &lt;test@runoob.com&gt;Date: Fri May 3 15:49:26 2019 +0800 changed the runoob.phpcommit c1501a244676ff55e7cccac1ecac0e18cbf6cb00Author: runoob &lt;test@runoob.com&gt;Date: Fri May 3 15:35:32 2019 +0800 我们可以用 –oneline 选项来查看历史记录的简洁的版本。 12345678$ git log --oneline$ git log --onelined5e9fc2 (HEAD -&gt; master) Merge branch 'change_site'c68142b 修改代码7774248 (change_site) changed the runoob.phpc1501a2 removed test.txt、add runoob.php3e92c19 add test.txt3b58100 第一次版本提交 这告诉我们的是，此项目的开发历史。 我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项： 12345678* d5e9fc2 (HEAD -&gt; master) Merge branch 'change_site'|\\ | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/ * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。 你也可以用 –reverse 参数来逆向显示所有日志。 1234567$ git log --reverse --oneline3b58100 第一次版本提交3e92c19 add test.txtc1501a2 removed test.txt、add runoob.php7774248 (change_site) changed the runoob.phpc68142b 修改代码d5e9fc2 (HEAD -&gt; master) Merge branch 'change_site' 如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分： 123456$ git log --author=Linus --oneline -581b50f3 Move 'builtin-*' into a 'builtin/' subdirectory3bb7256 make &quot;index-pack&quot; a built-in377d027 make &quot;git pack-redundant&quot; a built-inb532581 make &quot;git unpack-file&quot; a built-in112dd51 make &quot;mktag&quot; a built-in 如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）： 12345678910$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges5469e2d Git 1.7.1-rc2d43427d Documentation/remote-helpers: Fix typos and improve language272a36b Fixup: Second argument may be any arbitrary stringb6c8d2d Documentation/remote-helpers: Add invocation section5ce4f4e Documentation/urls: Rewrite to accomodate transport::address00b84e9 Documentation/remote-helpers: Rewrite description03aa87e Documentation: Describe other situations where -z affects git diff77bc694 rebase-interactive: silence warning when no commits rewritten636db2c t3301: add tests to use --format=&quot;%N&quot; 远程仓库(Github)Git 并不像 SVN 那样有个中心服务器。 目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。 本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 后面的 **your_email@youremail.com** 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码. 为了验证是否成功，输入以下命令： 12$ ssh -T git@github.comHi tianqixin! You've successfully authenticated, but GitHub does not provide shell access.","link":"/2019/05/16/Git-%E5%91%BD%E4%BB%A4/"},{"title":"Grub2 美化","text":"1.找资源个人认为比较好看的一款，Aurora-Penguinis-GRUB2; 下载，解压 温习一下解压常用的命令： * tar格式： × 解包：tar xvf filename.tar × 压缩：tar cvf filename * tar.gz 格式： × 解包：tar zxvf filename.tar.gz × 压缩：tar zcvf filename.tar.gz * zip格式： × 解包：unzip filename.zip × 压缩：zip filename.zip 2.开始配置 将解压好的文件夹复制到/boot/grub/themes文件夹下:sudo cp -r Aurora-Penguinis-GRUB2 /boot/grub/themes 设置这个主题为要使用的：sudo vim /etc/defalut/grub 在在这个文件中修改GRUB_THEME的值：GRUB_THEME=&quot;/boot/grub/themes/Aurora-Penguinis-GRUB2/theme.txt&quot; 更新Grub,让配置生效：grub-mkconfig -o /boot/grub/grub.cfg","link":"/2019/05/29/Grub2-%E7%BE%8E%E5%8C%96/"},{"title":"Git命令大全","text":"1.连接远程仓库 生成 SSH Key :ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 验证是否成功：ssh -T git@github.com 2.新建代码库 git init git init [project_name] git clone [url] 3.配置 git config --list # 显示当前的Git配置 git config --global user.name &quot;[userName]&quot; git config --global user.email &quot;[userEmail]&quot; 4.添加/删除文件 git add [filelist...] # 添加文件到暂存区 git add [dir] git add . git rm [filelist...] git rm --cached [file] # 停止追踪指定文件，但该文件会保留在工作区 5.代码提交 git commit -m &quot;[message]&quot; git commit -v # 提交时显示所有的diff信息 6.分支 git branch # 列出所有的本地分支 git branch -r # 列出所有的远程分支 git branch -a # 列出所有的分支 git branch [branch_name] git checkout -b [branch_name] # 创建新分支并切换到新分支 git merge [branch] # 合并指定分支到当前分支 git branch -d [branch_name] # 删除分支 7.远程同步 git remote add [remote] [url] # remote是仓库的别名，便于引用，增加一个的远程仓库 git fetch [remote] # 下载所有远程仓库变动 git remote -v # 显示所有远程仓库 git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并 git push [remote] [branch] # 上传本地分支到远程仓库 8.查看信息 git status # 显示有变更的文件 git log # 显示当前分支的版本历史 git show [commit] # 显示某次提交的元数据和内容变化","link":"/2019/05/22/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"},{"title":"HTML笔记","text":"1. 常用的标签&lt;html&gt; &lt;body&gt; &lt;title&gt; &lt;meta&gt; &lt;body&gt; 每个html文本都要有 &lt;p&gt; &lt;h1&gt;..&lt;h6&gt; &lt;hr&gt; &lt;br&gt; 段落，标题，分割线，换行 &lt;a href=&quot;link-url&quot;&gt;描述&lt;/a&gt; 2. 其他标签&lt;b&gt; &lt;i&gt; 加粗 ，斜体 &lt;strong&gt; &lt;em&gt; 重要文本 和上边两个标签视觉效果相似 &lt;a href=&quot;httpUrl&quot; target=&quot;_blank&quot;&gt;描述&lt;/a&gt; 3.HTML CSS 内联样式：在HTML属性内使用 &lt;p style=&quot;color:blue;margin-left:20px;&quot;&gt;这是一个段落。&lt;/p&gt; 内部样式表： 在&lt;head&gt;区域使用&lt;style&gt;123456&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;body {background-color:yellow;} p {color:blue;}&lt;/style&gt;&lt;/head&gt; 外部引用： 使用外部CSS文件 使用&lt;link&gt; 标签123&lt;head&gt;&lt;link ref=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;&lt;/head&gt; 4.元素标签图像&lt;img src=&quot;image-url&quot; alt=&quot;description&quot; width=&quot;100&quot; height=&quot;200&quot;&gt;表格123456&lt;table border=&quot;1&quot;&gt;&lt;tr&gt; &lt;td&gt;first row,first cell&lt;/td&gt; &lt;td&gt;first row,second cell&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 列表 有序列表 &lt;ol&gt;&lt;li&gt;the context of ol&lt;/li&gt;&lt;/ol&gt; 无序列表 &lt;ul&gt;&lt;li&gt;the context of ul&lt;/li&gt;&lt;/ul&gt; 自定义列表 &lt;dl&gt;&lt;dt&gt;the context of dl&lt;/dt&gt;&lt;dd&gt;description of dt&lt;/dd&gt;&lt;/dl&gt; 区块 大多数HTML元素被定义为块级元素和内联元素,块级元素在显示时，通常会以新行开始和结束,而内联元素不会以新行开始 &lt;div&gt; 是块级元素，它可用于组合其他HTML 的容器 &lt;span&gt; 是内联元素，可用作文本的容器 表单 表单是一个包含表单元素的区域，表单元素是指允许用户在表单元素中输入内容，比如: textarea(文本域), radio-buttons(单选框), checkbox(多选框), select(下拉列表)12345678910111213&lt;form name=&quot;input&quot; action=&quot;html_from_action.php&quot; mothod=&quot;get&quot;&gt;Username:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;Password:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;Female&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&gt;Bike&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot;&gt;Car&lt;br&gt;&lt;select name=&quot;cars&quot;&gt;&lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt;&lt;option value=&quot;jik&quot;&gt;Jik&lt;/option&gt;&lt;/select&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; 框架 定义一个内联的iframe &lt;iframe src=&quot;url&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; HTML 脚本&lt;script&gt;document.write(&quot;hello world!&quot;)&lt;/script&gt; END","link":"/2019/07/09/HTML%E7%AC%94%E8%AE%B0/"},{"title":"JS模拟前端路由","text":"路由是什么? 从用途上来说, 路由就是通过切换不同的URL向用户展示不同的界面内容. 从原理上来说, 路由是URL对函数或者资源的映射. 前端路由和后端路由 在后端路由中,每次切换URL都向服务器发送请求,服务器响应请求返回页面,这个URL可能对应一次资源读取或者是数据库操作,总之路由内容实际上是由后端决定的,当项目比较大时,后端开发的业务量会比较大,由于每次URL变化都要发送网络请求,页面加载耗时长,后端路由的用户体验也不好,并且也无法实现前后端分离开发. 前端路由即由前端决定路由的分发,这些路由通常对应着进行一些DOM操作,这样访问不同的路由,就可以显示不同的DOM结构.前端路由无需刷新页面,用户体验比较好,并且路由的路径和后台没有直接关系,由前端决定访问的内容或者对应的操作,可以实现前后端的分离开发. JS模拟前端路由 前端路由主要有两种方式, hash 和 history API. hash 通过切换 “#” 后的内容实现路由,本文通过 hashchange 监听 hash 的改变,通过 location.hash 改变hash history API 的url更美观,无需 “#”, 而是通过 history.pushState 和 history.replaceState实现URL的变化, 以pushState 为例, 执行函数后会向浏览器历史添加一个 state ,当浏览器触发动作时(前进后退),触发 window.popstate 事件, 可以看出, pushState 改变URL时并不会主动触发popstate事件, 所以无法实现主动的路由,解决办法是 包装 pushState 事件,使其被触发时主动分发一个事件,然后再监听事件做对应操作 CODE ⇩⇩⇩index.html12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;hash router&lt;/title&gt; &lt;script src=&quot;history.js&quot; defer&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;hash.js&quot; defer&gt;&lt;/script&gt; --&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;button @click=&quot;router1&quot; id=&quot;btn1&quot;&gt;page 1&lt;/button&gt; &lt;button @click=&quot;router2&quot; id=&quot;btn2&quot;&gt;page 2&lt;/button&gt; &lt;button @click=&quot;router3&quot; id=&quot;btn3&quot;&gt;page 3&lt;/button&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; .container { margin: 200px auto; text-align: center; } &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; hash.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * create by coody */const btn1 = document.getElementById('btn1')const btn2 = document.getElementById('btn2')const btn3 = document.getElementById('btn3')const contentContainer = document.getElementById('content')const content1 = document.createElement('h3')content1.innerText = 'This is content1'const content2 = document.createElement('h3')content2.innerText = 'This is content2'const content3 = document.createElement('h3')content3.innerText = 'This is content3'// 点击按钮, 向 location 添加对应 hashbtn1.addEventListener('click', () =&gt; { window.location.hash = 'content1'})btn2.addEventListener('click', () =&gt; { window.location.hash = 'content2'})btn3.addEventListener('click', () =&gt; { window.location.hash = 'content3'})// 清除 contentContainer 的子节点function clearChild() { let cList = contentContainer.children if (cList !== null) { for (let i = 0; i &lt; cList.length; i++) { contentContainer.removeChild(cList[i]) } }}// 监听 hash 变化, 触发相应 DOM 变动window.onhashchange = () =&gt; { switch (location.hash) { case '#content1': clearChild() contentContainer.appendChild(content1) break case '#content2': clearChild() contentContainer.appendChild(content2) break case '#content3': clearChild() contentContainer.appendChild(content3) break default: break }} history.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * creat by coody */const btn1 = document.getElementById('btn1')const btn2 = document.getElementById('btn2')const btn3 = document.getElementById('btn3')const contentContainer = document.getElementById('content')const content1 = document.createElement('h3')content1.innerText = 'This is content1'const content2 = document.createElement('h3')content2.innerText = 'This is content2'const content3 = document.createElement('h3')content3.innerText = 'This is content3'// 包装原来的 replaceState ,使其执行后自动分发同名事件const historyWrap = function (eventName) { const origEvent = history[eventName] const e = new Event(eventName) return function () { const origRs = origEvent.call(this, ...arguments) e.arguments = arguments window.dispatchEvent(e) return origRs }}// 包装 replaceStatehistory.replaceState = historyWrap('replaceState')btn1.addEventListener('click', () =&gt; { history.replaceState({ page: 1 }, '', '?content=1')})btn2.addEventListener('click', () =&gt; { history.replaceState({ page: 2 }, '', '?content=2')})btn3.addEventListener('click', () =&gt; { history.replaceState({ page: 3 }, '', '?content=3')})function clearChild() { let cList = contentContainer.children if (cList !== null) { for (let i = 0; i &lt; cList.length; i++) { contentContainer.removeChild(cList[i]) } }}// 监听分发的事件, 根据 state 判断对应页面内容window.addEventListener('replaceState', () =&gt; { switch (history.state.page) { case 1: clearChild() contentContainer.appendChild(content1) break case 2: clearChild() contentContainer.appendChild(content2) break case 3: clearChild() contentContainer.appendChild(content3) break default: break }})","link":"/2021/10/24/JS%E6%A8%A1%E6%8B%9F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"},{"title":"Linux 学习笔记","text":"linux系统启动过程linux 系统的启动过程可以分为5个阶段： * 内核的引导 * 运行init * 系统初始化 * 建立终端 * 用户系统登录 linux 常用命令目录类:1. ls 列出当前目录下的所有文件夹 * ls -a 包括隐藏文件 * ls -l 列出文件权限 * ls -la al组合 * ls -lh 常用，易读方式列出文件 * ls -lS 按文件大小降序排序 2. cd 改变工作目录 3. mkdir 创建目录 4. rmdir 删除空目录 5. cp 复制文件 6. mv 移动文件 7. du 显示文件使用的磁盘空间量 8. rm 删除文件或目录（不管是否为空） 9. tree 显示目录数的树状图表 10. file 显示文件的类型 11. chmod 更改文件或目录的文件权限 * ugo : user, group,other 分别表示当前用户，组用户，其他用户 * +-： 增加，删除权限 * rwx: read,write,execute 读写，执行权限 * 对应数字： r:4 w:2 x:1 * d: 文件夹 * -： 文件 * drwxr-xr-x : 此文件夹对于当前用户具有全部权限，组用户和其他用户只可读和可执行， 无法写入 12. pwd 显示当前路径 构建块:1. cat 以文本方式显示文件 （tac 倒着显示） 2. touch 文件存在刷新时间戳，不存在则创建文件和时间戳 3. alias 创建/显示别名 （unalias 删除别名） 4. echo 将数据写到标准输出，一般可以配合管道命令写入到文件中 5. less/more 分屏显示数据 6. head/tail 从数据的开头/末尾选择行 工具类：1. man 查看命令的帮助 2. --help 与 man 作用相同 3. tldr too long don&apos;t read工具 4. whatis 查看命令的介绍 5. whereis 命令所在位置 6. find 用法： find ToFindLocation -name FileName 7. grep 用法： grep [-l -v] &quot;findString&quot; ToFindPath","link":"/2019/06/20/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"紧急救援","text":"作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。 输入格式:输入第一行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0 ~ (N−1)；M是快速道路的条数；S是出发地的城市编号；D是目的地的城市编号。 第二行给出N个正整数，其中第i个数是第i个城市的救援队的数目，数字间以空格分隔。随后的M行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。 输出格式:第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从S到D的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。 输入样例:12345674 5 0 320 30 40 100 1 11 3 20 3 30 2 22 3 2 输出样例:122 600 1 3 用java实现的，最后一个测试点超时了（用c++重写后AC）。 思路：利用Dijkstra算法求最短路径，由于题目要求： 输出最短路径的条数和能够召集的最多的救援队数量 所以增加两个数组： pathTeams ： 当前城市集结的救援队伍的数量； shortPathNum ：源点到当前顶点存在的最短路径数量； 主要就是增加了存在相同长度最短路径时的处理，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Scanner;import java.util.Stack;public class EmergenceRescue { private static int[][] citys; private static int N,E,S,D; private static int INF = 10000; private static int[] teams; private static boolean[] visit; private static int[] dist; private static int[] path; private static int[] pathTeams; private static int[] shortPathNum; private static void InitCitys(Scanner scan) { N = scan.nextInt();E = scan.nextInt(); S = scan.nextInt();D= scan.nextInt(); citys = new int[N][N]; teams = new int[N]; for(int i = 0;i &lt; N;i++) { teams[i] = scan.nextInt(); } for(int i = 0;i &lt; N;i++) { for(int j = 0;j &lt; N;j++) { if(i == j) citys[i][j] = 0; else citys[i][j] = INF; } } } public static void CreateCitys(Scanner scan) { InitCitys(scan); for(int i = 0;i &lt; E;i++) { int v = scan.nextInt(),w = scan.nextInt(); int len = scan.nextInt(); citys[v][w] = citys[w][v] = len; } scan.close(); } public static void Dijkstra() { visit = new boolean[N]; dist = new int[N]; path = new int[N]; pathTeams = new int[N]; shortPathNum = new int[N]; for(int i = 0;i &lt; N;i++) { dist[i] = citys[S][i]; visit[i] = false; shortPathNum[i] = 1; pathTeams[i] = teams[i] + teams[S]; path[i] = S; } visit[S] = true; for(int i = 0;i &lt; N;i++) { int ans = INF,k = -1; for(int j = 0;j &lt; N;j++) { if(!visit[j] &amp;&amp; dist[j] &lt; ans) { ans = dist[j]; k = j; } } if(ans == INF) break; visit[k] = true; for(int j = 0;j &lt; N;j++) { if(!visit[j] &amp;&amp; dist[k] + citys[k][j] &lt;= dist[j]) { if(dist[k] + citys[k][j] &lt; dist[j]) { dist[j] = dist[k] + citys[k][j]; path[j] = k; pathTeams[j] = pathTeams[k] + teams[j]; shortPathNum[j] = shortPathNum[k]; }else { shortPathNum[j] += shortPathNum[k]; if(pathTeams[k] + teams[j] &gt; pathTeams[j] ) { pathTeams[j] = pathTeams[k] + teams[j]; path[j] = k; } } } } } } public static void OutputPath() { Stack&lt;Integer&gt; pathStack = new Stack&lt;Integer&gt;(); for(int i = D;i != S;i = path[i]) pathStack.push(i); System.out.print(S); while(!pathStack.isEmpty()) System.out.printf(&quot; %d&quot;,pathStack.pop()); } public static void main(String[] args) { Scanner scan = new Scanner(System.in); CreateCitys(scan); Dijkstra(); System.out.printf(&quot;%d %d\\n&quot;,shortPathNum[D],pathTeams[D]); OutputPath(); }}","link":"/2019/05/16/PAT/"},{"title":"Vim-初步","text":"vim 模式：vim有四个模式； 分别是 编辑模式：按ESC 进入 输入模式：i/a/o 或者 I/A/O 命令行模式：按：进入 选择模式：按 v 进入 vim 常用命令* w : 移动到下一个单词开头 * e : 移动到下一个单词结尾 * b : 移动到上一个单词开头 * f {char} 移动到下一个char字符上 / F （上一个） * 使用；或者，继续移动到下一个/上一个char * G : 移动到文本结束行开头 * gg: 移动到文本开始行开头 * ct&quot; : 删除从当前位置到“字符之间的内容 * ci{ : 修改{}内的内容 * /{word} ： 搜索word * daw/yaw/caw (dw/yw/cw):删除/复制/更改当前字符 * diw/yiw/ciw: 删除/复制/更改当前字符（不包括周围的空白符） * gi : 光标跳回到上一次编辑的位置并进入插入模式 * :saveas &lt;filename&gt; : 保存为filename * :e &lt;filename&gt; : 打开一个文件 * :wq :保存并离开 vim 高级用法：**未解锁**","link":"/2019/05/27/Vim-%E5%88%9D%E6%AD%A5/"},{"title":"nginx部署多个前端项目","text":"介绍关于如何将多个前端SPA部署在同一个域名服务器下,经过一番搜索和测试,个人总结了两种方式,实现这种需求.分别是: 通过二级域名配置 通过location目录配置 使用腾讯云的轻量云服务器, 系统 centos 7,Nginx版本 1.16.1,nginx配置文件位置: /etc/nginx/nginx.conf 通过二级域名配置 一种相对简单的方案是配置多个server,监听80端口下的不同server_name,示例如下:123456789101112131415161718192021// server aserver { listen 80; server_name a.test.com; location / { root /usr/share/nginx/a-test; index index.html; }}// server bserver { listen 80; server_name b.test.com; location / { root /usr/share/nginx/b-test; index index.html; }} 还可以通过端口转发的方式来实现多项目部署在多个端口下,配置相对繁琐,示例如下: 123456789101112131415161718192021222324252627282930313233343536// server aserver { listen 80; server_name a.test.com; location / { proxy_pass http://localhost:7070; }}server { listen 7070; location / { root /usr/share/nginx/a-test; index index.html; }}// server bserver { listen 80; server_name b.test.com; location / { proxy_pass http://localhost:7777; }}server { listen 7777; location / { root /usr/share/nginx/b-test; index index.html; }} 通过Location目录配置 这种方式不需要申请二级域名,nginx配置也比较简单,不过需要在项目中做一些修改.具体如下,假如域名为(www.test.com): 修改静态资源文件的根路径 publicPath, 比如该项目的域名目录为 www.test.com/a ,则修改publicPath 为 /a/ 提供vue-router的base参数,笔者使用了hash路由,应该对应修改为 craeteWebHashHistory(‘/a/‘) nginx 配置示例如下:12345678910111213141516171819server { listen 80; server_name www.test.com; location / { root /usr/share/nginx/html; index index.html; } location /a { alias /usr/share/nginx/html/a; index index.html; } location /b { alias /usr/share/nginx/html/b; index index.html; }}","link":"/2021/05/05/nginx%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"},{"title":"二分查找-扩展","text":"二分查找二分查找是一个基础算法，基本思想就是将查找的键和子数组的中间键作比较，如果查找的键小于中间键，那么在左子数组继续查找；如果大于中间键，那么在右子数组中查找，否则中间键就是要查找的元素。CODE ⇩⇩⇩1234567891011int binarySearch(const int *arr,int n,int key){ int lo = 0,hi = n-1; while(lo &lt;= hi){ int mid = lo + (hi-lo)/2; int cmp = arr[mid] - key; if(cmp == 0) return mid; if(cmp &lt; 0) lo = mid +1; else hi = mid - 1; } return -1;}注意点: 判断条件必须是lo&lt;=hi,否则判断条件不完整。 二分查找的变种如果二分查找的条件发生变化，比如：数组中的元素重复，要求返回匹配的数据的最大或最小下标；更进一步，需要找出数组中第一个大于Key的元素（最小的大于Key的元素）下标。实现的主体代码不发生变化，主要就是判断条件的变化（边界条件） 查找第一个与Key相等的元素有重复值，找到等于Key的最左边元素的下标1234567891011int binarySearch(const int *arr,int n,int key){ int lo = 0,hi = n-1; while(lo &lt;= hi){ int mid = lo + (hi-lo)/2; int cmp = arr[mid] - key; if(cmp &lt; 0) lo = mid +1; else hi = mid - 1; } if(lo &lt; n &amp;&amp; arr[lo] == key) return lo; return -1;} 查找最后一个与Key相等的元素多重复值，找到等于Key的最右边元素的下标1234567891011int binarySearch(const int *arr,int n,int key){ int lo = 0,hi = n-1; while(lo &lt;= hi){ int mid = lo + (hi-lo)/2; int cmp = arr[mid] - key; if(cmp &gt; 0) hi = mid - 1; else lo = mid +1; } if(hi &lt; n &amp;&amp; arr[hi] == key) return hi; return -1;} 查找第一个等于或者大于Key的元素如果有多个等于Key的值，返回最左边元素的下标; 否则返回大于Key的最左边元素下标12345678910int binarySearch(const int *arr,int n,int key){ int lo = 0,hi = n-1; while(lo &lt;= hi){ int mid = lo + (hi-lo)/2; int cmp = arr[mid] - key; if(cmp &lt; 0) lo = mid +1; else hi = mid - 1; } return lo;} 查找最后一个等于或者大于Key的元素如果有多个等于Key的元素，返回最右边元素的下标；否则返回小于Key的最右边元素下标12345678910int binarySearch(const int *arr,int n,int key){ int lo = 0,hi = n-1; while(lo &lt;= hi){ int mid = lo + (hi-lo)/2; int cmp = arr[mid] - key; if(cmp &gt; 0) hi = mid - 1; else lo = mid +1; } return hi;}","link":"/2020/01/23/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%89%A9%E5%B1%95/"},{"title":"动漫美图","text":"Wallpapers一些可用的壁纸&gt;&gt;","link":"/2019/05/16/%E5%8A%A8%E6%BC%AB%E7%BE%8E%E5%9B%BE/"},{"title":"搜索二叉树(c++ implementation)","text":"二叉搜索树简要介绍二叉搜索树的定义： 二叉搜索树又叫二叉查找树，它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。 树的种类很多，除了二叉搜索树(BST),还有平衡二叉树（AVL）,红黑树，B树，B+树等等。 二叉搜索树的实现数据结构及接口的定义 添加了父节点的指针，便于实现删除操作。（也可以使用引用）节点的定义如下123456789typedef struct node *nodePtr;static nodePtr root;struct node{ int val; nodePtr parent; nodePtr left{}; nodePtr right{}; explicit node(int val,nodePtr parent){this-&gt;val = val;this-&gt;parent = parent;}}; 树的遍历都是老生常谈的话题了，这里不再赘述。主要实现的树的插入，构造，删除等操作。实现的接口如下12345678910nodePtr find(int val,nodePtr np);nodePtr findMax(nodePtr np);nodePtr findMin(nodePtr np);nodePtr insert(int val,nodePtr np,nodePtr pnt);nodePtr CreateBST(const vector&lt;int&gt; &amp;vc);void adjustNode(nodePtr &amp;np,nodePtr &amp;tnp); //引用，修改节点int deleteMin(nodePtr np);void deleteNode(int val);void levelTraverse();void inOrderTraverse(nodePtr np); CODE ⇩⇩⇩12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct node *nodePtr;static nodePtr root;struct node{ int val; nodePtr parent; nodePtr left{}; nodePtr right{}; explicit node(int val,nodePtr parent){this-&gt;val = val;this-&gt;parent = parent;}};nodePtr find(int val,nodePtr np){ if(np == nullptr) return nullptr; if(np-&gt;val == val) return np; if(val &lt; np-&gt;val) return find(val,np-&gt;left); else return find(val,np-&gt;right);}nodePtr findMax(nodePtr np){ if(np == nullptr) return nullptr; if(np-&gt;right == nullptr) return np; return findMax(np-&gt;right);}nodePtr findMin(nodePtr np){ if(np == nullptr) return nullptr; if(np-&gt;left == nullptr) return np; return findMin(np-&gt;left);}nodePtr insert(int val,nodePtr np,nodePtr pnt){ if(np == nullptr) return new node(val,pnt); if(val &lt; np-&gt;val) np-&gt;left = insert(val,np-&gt;left,np); else np-&gt;right = insert(val,np-&gt;right,np); return np;}nodePtr CreateBST(const vector&lt;int&gt; &amp;vc){ for(int i: vc) root = insert(i,root,nullptr); return root;}void adjustNode(nodePtr &amp;np,nodePtr &amp;tnp){ (np-&gt;val &lt; np-&gt;parent-&gt;val ? np-&gt;parent-&gt;left : np-&gt;parent-&gt;right) = tnp; if(tnp) tnp-&gt;parent = np-&gt;parent; delete np;}int deleteMin(nodePtr np){ nodePtr minPtr = findMin(np); int minVal = minPtr-&gt;val; adjustNode(minPtr,minPtr-&gt;right); return minVal;}void deleteNode(int val){ nodePtr np = find(val, root); if(np == nullptr) return; if(np-&gt;left == nullptr) adjustNode(np, np-&gt;right); else if(np-&gt;right == nullptr) adjustNode(np,np-&gt;left); else np-&gt;val = deleteMin(np-&gt;right);}void levelTraverse(){ queue&lt;nodePtr&gt; levelQueue; levelQueue.push(root); while(!levelQueue.empty()){ nodePtr cur = levelQueue.front(); cout&lt;&lt;(cur-&gt;val)&lt;&lt;&quot; &quot;; if(cur-&gt;left) levelQueue.push(cur-&gt;left); if(cur-&gt;right) levelQueue.push(cur-&gt;right); levelQueue.pop(); } cout&lt;&lt;endl;}void inOrderTraverse(nodePtr np){ if(np == nullptr) return; inOrderTraverse(np-&gt;left); cout&lt;&lt;np-&gt;val&lt;&lt;&quot; &quot;; inOrderTraverse(np-&gt;right);}int main() { int lis[10] = {88,70,61,96,120,90,65,75,93,100}; vector&lt;int&gt; vc(lis,lis+10); root = CreateBST(vc); levelTraverse(); inOrderTraverse(root); cout&lt;&lt;endl; deleteNode(96); deleteNode(70); deleteNode(88); deleteNode(11); levelTraverse(); inOrderTraverse(root); cout&lt;&lt;endl; return 0;}","link":"/2020/02/05/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91-c-implementation/"},{"title":"用VPS搭建ownCloud私有云","text":"ownCloud 安装 踩坑本来打算直接按照官方教程安装的，但PHP环境配置一直出问题,最后还是用docker了(省心系统： CentOS7VPS：hostwinds 安装docker 检查内核版本，（&gt;= 3.8)12# uname -r3.10.0-957.27.2.el7.x86_64 删除自带的docker,如果有的话1# yum erase docker -y 安装一些必要的系统工具： 1# yum install -y yum-utils device-mapper-persistent-data lvm2 添加软件源信息：1# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新 yum 缓存：1# yum makecache fast 安装 Docker-ce：1# yum -y install docker-ce 启动 Docker 后台服务1# systemctl start docker docker 安装 owncloud 拉取owncloud官方镜像1# sudo docker pull owncloud owncloud默认使用SOLite,但是对于更大的安装，官方推荐使用另外的数据库(mariadb/mysql等)1# docker pull mysql 启动mysql容器，用作owncloud容器的数据库1# docker run --name own-mysql -e MYSQL_ROOT_PASSWORD=&quot;password&quot; -d mysql 启动owncloud容器1# docker run --name owncloud -p 8008:80 -v /data/db/owncloud:/var/www/html/data --link own-mysql:mysql -d owncloud -p 8008:80: 将容器的80端口映射到宿主机的8008端口–link own-mysql:mysql -d owncloud: 将owncloud容器(客户)链接到own-mysql容器(服务),链接别名：mysql 配置owncloud在浏览器上访问 http:IP:8008,设置owncloud,这里遇到了问题The server requested authentication method unknown to the clientgoogle了一下是由于新版本的mysql帐号密码解锁机制不一致导致的 解决办法： 进入mysql的bash中123# docker exec -it own-mysql bash# docker pull vim# vim /etc/mysql/my.cnf 修改这个文件：12[mysqld]default_authentication_plugin=mysql_native_password 配置mysql：12345# mysql -u root -pEntry Password: [YOUR PASSWORD]# CREATE USER 'root'@'localhost' IDENTIFIED BY 'password';# GRANT ALL PRIVILEGES ON * . * TO 'root'@'localhost';# FLUSH PRIVILEGES; 最后重启mysql1# docker restart own-mysql END","link":"/2019/08/19/%E7%94%A8VPS%E6%90%AD%E5%BB%BAownCloud%E7%A7%81%E6%9C%89%E4%BA%91/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"grub","slug":"grub","link":"/tags/grub/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"文本标记","slug":"文本标记","link":"/tags/%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"PAT练习","slug":"PAT练习","link":"/tags/PAT%E7%BB%83%E4%B9%A0/"},{"name":"vim","slug":"vim","link":"/tags/vim/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"Learn","slug":"Learn","link":"/tags/Learn/"},{"name":"wallpaper","slug":"wallpaper","link":"/tags/wallpaper/"},{"name":"vps","slug":"vps","link":"/tags/vps/"}],"categories":[{"name":"记录","slug":"记录","link":"/categories/%E8%AE%B0%E5%BD%95/"},{"name":"刷题","slug":"刷题","link":"/categories/%E5%88%B7%E9%A2%98/"},{"name":"Picture","slug":"Picture","link":"/categories/Picture/"}]}