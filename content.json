{"pages":[],"posts":[{"title":"Git 命令","text":"Git 命令＞＞创建仓库：git initGit 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。 在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。 使用方法使用当前目录作为Git仓库，我们只需使它初始化。 1git init 该命令执行完后会在当前目录生成一个 .git 目录。 使用我们指定目录作为Git仓库。 1git init newrepo 初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。 如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交： 123$ git add *.c$ git add README$ git commit -m &apos;初始化项目版本&apos; 以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。 git clone我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。 克隆仓库的命令格式为： 1git clone &lt;repo&gt; 如果我们需要克隆到指定的目录，可以使用以下命令格式： 1git clone &lt;repo&gt; &lt;directory&gt; 参数说明： repo:Git 仓库。 directory:本地目录。 比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： 1$ git clone git://github.com/schacon/grit.git 执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。 如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字： 1$ git clone git://github.com/schacon/grit.git mygrit 基本操作：git addgit add 命令可将该文件添加到缓存，如我们添加以下两个文件： 12345678$ touch README$ touch hello.php$ lsREADME hello.php$ git status -s?? README?? hello.php$ git status 命令用于查看项目的当前状态。 接下来我们执行 git add 命令来添加文件： 1$ git add README hello.php 现在我们再执行 git status，就可以看到这两个文件已经加上去了。 1234$ git status -sA READMEA hello.php$ git status 命令用于查看项目的当前状态。 接下来我们执行 git add 命令来添加文件： 1$ git add README hello.php 现在我们再执行 git status，就可以看到这两个文件已经加上去了。 1234$ git status -sA READMEA hello.php$ git status 命令用于查看项目的当前状态。 接下来我们执行 git add 命令来添加文件： 1$ git add README hello.php 现在我们再执行 git status，就可以看到这两个文件已经加上去了。 1234$ git status -sA READMEA hello.php$ git statusgit status 以查看在你上次提交之后是否有修改。 我演示该命令的时候加了 -s 参数，以获得简短的结果输出。如果没加该参数会详细输出内容： 12345678910$ git statusOn branch masterInitial commitChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: README new file: hello.php git diff执行 git diff 来查看执行 git status 的结果的详细信息。 git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。 尚未缓存的改动：git diff 查看已缓存的改动： git diff –cached 查看已缓存的与未缓存的所有改动：git diff HEAD 显示摘要而非整个 diff：git diff –stat git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。 git commit使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。 Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。 12$ git config --global user.name &apos;runoob&apos;$ git config --global user.email test@runoob.com 接下来我们写入缓存，并提交对 hello.php 的所有改动。在首个例子中，我们使用 -m 选项以在命令行中提供提交注释。 123456789$ git add hello.php$ git status -sA READMEA hello.php$ git commit -m &apos;第一次版本提交&apos;[master (root-commit) d32cf1f] 第一次版本提交 2 files changed, 4 insertions(+) create mode 100644 README create mode 100644 hello.php 现在我们已经记录了快照。如果我们再执行 git status: 123$ git status# On branch masternothing to commit (working directory clean) 以上输出说明我们在最近一次提交之后，没有做任何改动，是一个”working directory clean：干净的工作目录”。 分支管理:几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。 有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。 列出分支创建分支命令： 1git branch (branchname) 切换分支命令: 1git checkout (branchname) 当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。 合并分支命令: 1git merge 你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。 开始前我们先创建一个测试目录： 12345678910$ mkdir gitdemo$ cd gitdemo/$ git initInitialized empty Git repository...$ touch README$ git add README$ git commit -m &apos;第一次版本提交&apos;[master (root-commit) 3b58100] 第一次版本提交 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README 列出分支基本命令： 1git branch 没有参数时，git branch 会列出你在本地的分支。 12$ git branch* master 此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。 当你执行 git init 的时候，缺省情况下 Git 就会为你创建 master 分支。 如果我们要手动创建一个分支。执行 git branch (branchname) 即可。 1234$ git branch testing$ git branch* master testing 现在我们可以看到，有了一个新分支 testing。 当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。 接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。 1234567891011121314$ lsREADME$ echo &apos;runoob.com&apos; &gt; test.txt$ git add .$ git commit -m &apos;add test.txt&apos;[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME test.txt$ git checkout testingSwitched to branch &apos;testing&apos;$ lsREADME 当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。 删除分支删除分支命令： 1git branch -d (branchname) 例如我们要删除 testing 分支： 1234567$ git branch* master testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master 分支合并一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去： 12345678910111213141516git merge$ git branch* master newtest$ lsREADME test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME runoob.php 以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。 合并完后就可以删除分支: 12$ git branch -d newtestDeleted branch newtest (was c1501a2). 删除后， 就只剩下 master 分支了： 12$ git branch* master 查看提交历史在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。 针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下： 1234567891011121314151617181920212223$ git logcommit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)Merge: c68142b 7774248Author: runoob &lt;test@runoob.com&gt;Date: Fri May 3 15:55:58 2019 +0800 Merge branch &apos;change_site&apos;commit c68142b562c260c3071754623b08e2657b4c6d5bAuthor: runoob &lt;test@runoob.com&gt;Date: Fri May 3 15:52:12 2019 +0800 修改代码commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)Author: runoob &lt;test@runoob.com&gt;Date: Fri May 3 15:49:26 2019 +0800 changed the runoob.phpcommit c1501a244676ff55e7cccac1ecac0e18cbf6cb00Author: runoob &lt;test@runoob.com&gt;Date: Fri May 3 15:35:32 2019 +0800 我们可以用 –oneline 选项来查看历史记录的简洁的版本。 12345678$ git log --oneline$ git log --onelined5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;c68142b 修改代码7774248 (change_site) changed the runoob.phpc1501a2 removed test.txt、add runoob.php3e92c19 add test.txt3b58100 第一次版本提交 这告诉我们的是，此项目的开发历史。 我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项： 12345678* d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;|\\ | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/ * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。 你也可以用 –reverse 参数来逆向显示所有日志。 1234567$ git log --reverse --oneline3b58100 第一次版本提交3e92c19 add test.txtc1501a2 removed test.txt、add runoob.php7774248 (change_site) changed the runoob.phpc68142b 修改代码d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos; 如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分： 123456$ git log --author=Linus --oneline -581b50f3 Move &apos;builtin-*&apos; into a &apos;builtin/&apos; subdirectory3bb7256 make &quot;index-pack&quot; a built-in377d027 make &quot;git pack-redundant&quot; a built-inb532581 make &quot;git unpack-file&quot; a built-in112dd51 make &quot;mktag&quot; a built-in 如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）： 12345678910$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges5469e2d Git 1.7.1-rc2d43427d Documentation/remote-helpers: Fix typos and improve language272a36b Fixup: Second argument may be any arbitrary stringb6c8d2d Documentation/remote-helpers: Add invocation section5ce4f4e Documentation/urls: Rewrite to accomodate transport::address00b84e9 Documentation/remote-helpers: Rewrite description03aa87e Documentation: Describe other situations where -z affects git diff77bc694 rebase-interactive: silence warning when no commits rewritten636db2c t3301: add tests to use --format=&quot;%N&quot; 远程仓库(Github)Git 并不像 SVN 那样有个中心服务器。 目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。 本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 后面的 **your_email@youremail.com** 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码. 为了验证是否成功，输入以下命令： 12$ ssh -T git@github.comHi tianqixin! You&apos;ve successfully authenticated, but GitHub does not provide shell access.","link":"/2019/05/16/Git-命令/"},{"title":"紧急救援","text":"作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。 输入格式:输入第一行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0 ~ (N−1)；M是快速道路的条数；S是出发地的城市编号；D是目的地的城市编号。 第二行给出N个正整数，其中第i个数是第i个城市的救援队的数目，数字间以空格分隔。随后的M行中，每行给出一条快速道路的信息，分别是：城市1、城市2、快速道路的长度，中间用空格分开，数字均为整数且不超过500。输入保证救援可行且最优解唯一。 输出格式:第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从S到D的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。 输入样例:12345674 5 0 320 30 40 100 1 11 3 20 3 30 2 22 3 2 输出样例:122 600 1 3 用java实现的，最后一个测试点超时了（用c++重写后AC）。 思路：利用Dijkstra算法求最短路径，由于题目要求： 输出最短路径的条数和能够召集的最多的救援队数量 所以增加两个数组： pathTeams ： 当前城市集结的救援队伍的数量； shortPathNum ：源点到当前顶点存在的最短路径数量； 主要就是增加了存在相同长度最短路径时的处理，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Scanner;import java.util.Stack;public class EmergenceRescue { private static int[][] citys; private static int N,E,S,D; private static int INF = 10000; private static int[] teams; private static boolean[] visit; private static int[] dist; private static int[] path; private static int[] pathTeams; private static int[] shortPathNum; private static void InitCitys(Scanner scan) { N = scan.nextInt();E = scan.nextInt(); S = scan.nextInt();D= scan.nextInt(); citys = new int[N][N]; teams = new int[N]; for(int i = 0;i &lt; N;i++) { teams[i] = scan.nextInt(); } for(int i = 0;i &lt; N;i++) { for(int j = 0;j &lt; N;j++) { if(i == j) citys[i][j] = 0; else citys[i][j] = INF; } } } public static void CreateCitys(Scanner scan) { InitCitys(scan); for(int i = 0;i &lt; E;i++) { int v = scan.nextInt(),w = scan.nextInt(); int len = scan.nextInt(); citys[v][w] = citys[w][v] = len; } scan.close(); } public static void Dijkstra() { visit = new boolean[N]; dist = new int[N]; path = new int[N]; pathTeams = new int[N]; shortPathNum = new int[N]; for(int i = 0;i &lt; N;i++) { dist[i] = citys[S][i]; visit[i] = false; shortPathNum[i] = 1; pathTeams[i] = teams[i] + teams[S]; path[i] = S; } visit[S] = true; for(int i = 0;i &lt; N;i++) { int ans = INF,k = -1; for(int j = 0;j &lt; N;j++) { if(!visit[j] &amp;&amp; dist[j] &lt; ans) { ans = dist[j]; k = j; } } if(ans == INF) break; visit[k] = true; for(int j = 0;j &lt; N;j++) { if(!visit[j] &amp;&amp; dist[k] + citys[k][j] &lt;= dist[j]) { if(dist[k] + citys[k][j] &lt; dist[j]) { dist[j] = dist[k] + citys[k][j]; path[j] = k; pathTeams[j] = pathTeams[k] + teams[j]; shortPathNum[j] = shortPathNum[k]; }else { shortPathNum[j] += shortPathNum[k]; if(pathTeams[k] + teams[j] &gt; pathTeams[j] ) { pathTeams[j] = pathTeams[k] + teams[j]; path[j] = k; } } } } } } public static void OutputPath() { Stack&lt;Integer&gt; pathStack = new Stack&lt;Integer&gt;(); for(int i = D;i != S;i = path[i]) pathStack.push(i); System.out.print(S); while(!pathStack.isEmpty()) System.out.printf(\" %d\",pathStack.pop()); } public static void main(String[] args) { Scanner scan = new Scanner(System.in); CreateCitys(scan); Dijkstra(); System.out.printf(\"%d %d\\n\",shortPathNum[D],pathTeams[D]); OutputPath(); }}","link":"/2019/05/16/PAT/"},{"title":"动漫美图","text":"Wallpapers一些可用的壁纸&gt;&gt;","link":"/2019/05/16/动漫美图/"}],"tags":[{"name":"git","slug":"git","link":"/tags/git/"},{"name":"PAT练习","slug":"PAT练习","link":"/tags/PAT练习/"},{"name":"wallpaper","slug":"wallpaper","link":"/tags/wallpaper/"}],"categories":[{"name":"记录","slug":"记录","link":"/categories/记录/"},{"name":"刷题","slug":"刷题","link":"/categories/刷题/"},{"name":"Picture","slug":"Picture","link":"/categories/Picture/"}]}